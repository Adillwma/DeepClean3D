import numpy as np 
import matplotlib.pyplot as plt
import torchvision
from torchvision import transforms
from torch.utils.data import DataLoader, random_split
from torch import nn
from scipy.spatial.distance import cdist

"""
This is a test new loss function taking into account what was brought up in the meeting on the 3rd of march.
This loss function below will take in both the denoised image and the original image.
What was brought up in the meeting was a potential blurring of the image, so that points surrounding the signal points
in the x and y axis have somewhat something to do with the signal point.

My logic:
Loss is currently MSE on 0, but we want to incentivize it, or at least penalise it less, for making a guess, as long
as its within reason. I will make an initial one that has a gaussian error around the signal point and then the usual to 0.
hence, either choise is ok, but it will still be rewarded by taking the correct guess, and is able to reach a lower
minimum loss if it does.

Can add later:
- faster way to do calculation as its likely v slow.
- adding information transfer in x- y axis (if its actually needed)
"""

# the MSE loss function, just to help with understanding it:
def MSE_loss_fn(denoised, original):

    # zip the two together:
    paired = zip(denoised, original)

    # define list of MSE:
    MSE = []

    # loop through each pixel in the denoised/ original:
    for pair in paired:

        # assuming the time value (z-axis) is in the second index:
        MSE.append((pair[0][2] - pair[1][2])**2)
    
    return MSE

# testing
# a = [[0,0,0],[0,0,2],[0,0,3]]
# b = [[0,0,2],[0,0,5],[0,0,3]]
# print(loss_fn(a,b))

# this may take far too long to compute, as it will have to find a distance for each point. There will be 
# methods to reduce this somehow but can have a look into it later
# def custom_loss_fn(denoised, original):

#     # each point in denoised needs a distance to the closesest signal point in original
#     # in order to see how wrong it is.
#     dist_lst = []

#     minimum = 1000

#     # loop through the denoised image
#     for den_pix in denoised:
        
#         # loop through the original pixels to find closest
#         for orig_pix in original:
            
#             dist = ((den_pix[0] - orig_pix[0])**2+(den_pix[1] - orig_pix[1])**2+(den_pix[2] - orig_pix[2])**2)**(1/2)

#             # change minimum to the closest signal point
#             if dist < minimum:
#                 minimum = dist

# ---------------------------------------------------------------------------------------------------------------------

# here i did some research, and apparently the cdist is the best method to use from scipy lib. It is used in 
# k-nearest neighbour: 
def custom_loss_fn2(denoised, original, factor):
    """
    denoised is individual denoised image
    original is individual original image
    factor is how tight you want the loss to be around the signal points.

    """

    # use list of values without zeros to find distances:
    sig_pts = np.array([i for i in original if i[2] > 0])

    # Compute pairwise distances
    # this finds the distance to EVERY point in denoised to signal points in massive matrix.
    sig_dist = cdist(denoised, sig_pts)

    # this is the dist of the point to 0
    base_dist = 

    # Find the minimum distance for each pixel in denoised
    # min_distances = np.min(distances, axis=1)

    # Reshape the min_distances array to match the shape of denoised
    # min_distances = min_distances.reshape(denoised.shape)

    return distances
        
# testing
a = np.array([[0,1,1],[0,0,2],[0,0,3]])
b = np.array([[0,0,0],[0,0,2]])
print(custom_loss_fn2(a,b))
